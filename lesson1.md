# Урок 1. Первая программа

Структура программы, вывод. 

## Первая пустая программа
```c++
int main()
{
    return 0;
}
```
Каждая программа на С++ содержит функцию `main()`. Функция - это часть программы с именем, по которому другая часть программы может ее **вызывать** (call). Каждая программа на С++ должна содержать функцию `main()`, эту функцию вызывает операционная система, когда мы выполняем программу. Функция `main()` называется **точкой входа**. Должна быть в каждой вашей программе.

При вызове функция `main()` должна вернуть операционной системе целое число, сообщающее о том, насколько успешно программа выполнилась. Чтобы показать, что функция возвращает целое число, перед ее именем стоит **идентификатор типа** `int` = integer = целый.

Описание функции ::= тип_возвращаемого_значения _имя_функции_ (список_параметров) {тело_функции}

Значок `::=` обозначает слово "есть".

    `int main() { ... }` - определение функции

        `int` - тип возвращаемого значения функции 

        `main` - имя функции

        `()` - список параметров, пока пустой 

        `{}` - тело функции (что она делает). Все, что заключено между фигурными скобками, называется **блоком** инструкций. `{` показывает начало инструкций нашей функции `main()`,  `}` показывает конец. То есть, фигурные скобки показывают, что все инструкции, расположенные между ними являются частью одной функции.

Сейчас в нашей функции единственная инструкция - оператор `return` с аргументом. У него 2 основные задачи:
1) Завершить программу, 
2) Если у `return`есть операнд (`return **0**`): передать значение назад тому, кто вызвал функцию. В нашем случае функцию `main()` вызывает операционная система, поэтому то, что возвращает `return` - индикатор того, как выполнилась программа.  

Обычно, возврат нулевого значения показывает, что программа выполнилась без ошибок. 

Конечно, код возврата функции `main()` может быть ненулевым.

### return

Попробуйте написать `return` с различными числами: положительными и отрицательными, большими и маленькими. Значения, которые вы будете видеть будут ограничены. Например, если вы запускаете код под Unix-based операционными системами (как в школе, какой-то Linux), то любой код возврата функции `main()` будет взят по модулю 256 (почему? - хороший вопрос! Запомните его, вернемся, когда будем подробно говорить о типах данных). А на этот вопрос вы, скорее всего, можете ответить: почему -1 выводится как 255? В Windows кодов возврата гораздо больше, есть даже отрицательные. 

Мы можем сами заставить программу завершиться с каким-то ненулевым кодом возврата. Это делается с помощью `return что-то` или специальной функции `exit(что-то)`, где "что-то" - это специальный код возврата. 

Есть операционные системы,в которых успешное завершение программы - это не всегда 0, а завершение с ошибкой - не всегда 1. То есть успех и ошибка могут обозначаться разными числами. Такие значения обычно называют **`implementation defined`**, то есть, зависящими от реализации.Поэтому, чтобы ваша программа работала правильно на любой операционной системе, можно использовать специальные слова: EXIT_SUCCESS и EXIT_FAILURE. Это **константы**, в которых хранятся конкретные значения кодов возврата. EXIT_SUCCESS и EXIT_FAILUR записаны в специальном файле `<cstdlib>`, который нужно подключить с помощью **директивы** `#include`. 
**Директивы** - это инструкции препроцессору, все директивы начинаются с `#`, каждая директива помещается на отдельной строке. 
То есть, написать 

```c++
    #include <iostream> #include <stdio.h>
```

По внешнему эффекту действие `#include` похоже на `import` в питоне, но в реальности все сложнее, об этом поговорим позже.

**Task:** поэкспериментируйте, замените в своей программе `return 0` на `return EXIT_FAILURE` или `return EXIT_SUCCESS`.

**Task:** попробуйте запустить такую программу, что получилось?:
```c++
// Программа, демонстрирующая деление на 0
// Ошибка называется: Floating Point Error
#include <iostream>
 
int main()
{
    // создаем и инициализируем 2 переменных типа int (целые числа)
    int a = 1, b = 0; 
 
    // Идем против природы и делим на 0 \/
    std::cout << a / b;
    return 0;
}
```
Вероятнее всего, вы видите сообщение "Floating point exception", которое было вызвано выходом программы с сигналом: SIGFPE. Это один из заданных на уровне операционной системы сигналов прерывания программы (ошибка в числах с плавающей точкой, превышение времени выполнения, обращение к недоступной памяти и тд.).   

Подробнее:
1. https://www.geeksforgeeks.org/exit-codes-in-c-c-with-examples/
2. https://en.cppreference.com/w/cpp/utility/program/SIG_types

Функция `main()` всегда возвращает целое число, без разницы: хотим мы этого, или нет. Поэтому, даже если мы не будем писать `return 0`, число, сообщающее, насколько успешно выполнилась программа, все равно будет возвращено операционной системе.

### check yourself

Перед тем, как идти дальше, убедитесь, что вы понимаете:
1. Что произойдет, если запустить такую программу (сначала сделайте предположение, потом запустите код и проверьте, потом постарайтесь найти объяснение):
```c++
int main()
{
    return 2;
    return 1;
    return 100;
}
```
2. Что произойдет, если запустить такую программу:
```c++
int main()
{
    return;
}
``` 
3. Что произойдет, если запустить такую программу:
```c++
void main()
{
    return 0;
}
```
4. Что произойдет, если запустить такую программу:
```c++
void main()
{
    return;
}
```
5. Как выглядит самая короткая работающая программа на С++?

## Ввод-вывод

Рассмотрим программу посложнее.

```c++ 
// Маленькая программка на С++
#include <iostream>
int main()
{
    std::cout << "I came, I saw, I conquered!" << std::endl;
}
```

Ура, теперь инструкция в теле функции `main()` наконец-то выполняет реальное действие в нашей программе! Эта программа записывает текст "I came, I saw, I conquered!" в стандартный выходной поток (в большинстве случаев это консоль (окно, которое появляется, когда вы запускаете программу)) .

Разберем эту программу по частям:

### 1. Комментарии:
`// Маленькая программка на С++`
**Комментарии** начинаются с `//` и продолжаются до конца строки. Комментарии игнорируются компилятором. Обычно в комментариях объясняют составные части программы.
Для того, чтобы закомментировать несколько строк или текст внутри строки используют вложенные комментарии:
```c++
/*
П устая программа

Разработчик: Израилева Арина
Дата: 23.09.2023
*/
int main()
{
    return /*комментарии в середине строк лучше не писать :)*/0;
}
```

### 2. Директива #include
В С++ многие полезные средства языка (ввод-вывод, контейнеры, математические функции и тд) не входят в **базовый язык** (core language), а являются частью **стандартной библиотеки** (standard library). Почему это так сделано? 

В **core language** включает в себя синтаксис и базовые конструкции языка (типы данных, операторы: +, -, << и тд., средства для создания классов и объектов, для работы с указателями и выделением памяти и тд.). То есть в core language описаны базовые инструменты, из которых можно создать все-что угодно. А в **standart library** включает полезные средства разработки (объекты ввода-вывода, контейнеры для хранения данных, математические функции и тд), эти средства при желании мы можем и сами написать, но, вероятнее всего, не так эффективно и совершив множество ошибок в процессе. 

Чтобы использовать средства стандартной библиотеки, используют **директиву** `#include`, переводится как "включить". **Директива** - это инструкция препроцессору, который обрабатывает наш код на С++ ещё до того, как программа будет скомпилирована, все директивы начинаются с `#`. Директива `#include` по внешнему эффекту очень похожа на `import` из Python, хотя по физическому смыслу это *очень* разные вещи. То, что мы хотим включить с помощью `#include`, записывается внутри `<...>` (или иногда можно встретить внутри `"..."`). Подробнее мы обсудим на следующих занятиях.

В нашей программе мы хотим сделать вывод текста на экран, поэтому используем библиотеку ввода-вывода `<iostream>` = **i**nput/**o**utput **stream** = поток ввода-вывода.

### Вывод текста

Теперь единственная инструкция в теле функции `main()` делает что-то полезное! Она выводит на экран текст "I came, I saw, I conquered!":

Перед тем, как подробнее рассмотреть эту строчку, договоримся о формулировках:

**Операция**: +, -, =, /, %, <<, >> и многие другие.
**Выражение**: операции и операнды, например, `3 * x + 4 / sin(y)`. Это выражение состоит из операций: `*, +, /` и операндов: `3, x, 4, sin(y)`.
**Инструкция** или **оператор**: выражение, оканчивающееся точкой с запятой `;`. `;` - тоже оператор, называется "пустой оператор".  

`std::cout << "I came, I saw, I conquered!" << std::endl;`

Перед нами **выражение**, состоящее из 4х сущностей (`std::cout`, `<<`, текста и `std::endl`), оканчивается точкой с запятой. Значит перед нами **инструкция**.

`<<` - оператор вывода стандартной библиотеки. Используем его два раза: первый для вывода в стандартный поток текста `"I came, I saw, I conquered!"`, второй - для вывода `std::endl`. 

`std::`
Префикс `std::` (**st**andar**d**) показывает, что имя, которое идет после него, относится к стандартной библиотеке. Если мы не напишем этот префикс, компиллятор будет искать имена `cout` и `endl` только в нашем коде, а не в коде стандартной библиотеки. Так происходит, потому что все имена стандартной библиотеки определены в специальном **пространстве имен** (**namespace**) - `std`. Для того, чтобы показать, что какое-то имя принадлежит конкретному namspace-y ставят `::`. То есть `std::cout` означает: имя `cout` из пространства имен стандартной библиотеки `std`.

`std::cout` (**c**haracter **out**put = вывод символа) - стандартный выходной поток, в наших операционных системах это окно, которое появляется во время выполнения программы. Когда мы с помощью оператора `<<` отправляем в выходной поток текст, он отображается в этом окне.

`std::endl` (**end** **l**ine = конец строки) - манипулятор, который завершает строку входных данных. После этого следующие входные данные отобразятся на новой строке.

То есть сейчас в выходной поток `std::cout` мы отправляем сначала текст, а потом завершающий строку манипулятор `std::endl`. Оба раза делаем это с помощью операции `<<`. 

`<<` - операция, у которой, интуитивно понятно, должно быть 3 операнда. Но мы записали 2 операции и 3 операнда! Как это работает? 

У каждой операции есть свои **операнды** и **возвращаемое значение**. У операции `+` и левый, и правый операнд - числа; возвращаемое значение - тоже число. 

У операции `<<` все чуть-чуть сложнее.

Левый операнд - **максимально** возможная часть выражения, которую можно рассмотреть в качестве операнда.
Правый операнд - **минимально** возможная часть выражения, которую можно рассмотреть в качестве операнда.
Возвращаемое значение - левый операнд.

То есть в нашем примере
Для левого `<<` левый операнд: `std::cout`, правый операнд: `"I came, I saw, I conquered!"`.

Для правого `<<` левый операнд: `std::cout << "I came, I saw, I conquered!"`, правый операнд: `std::endl`;

То есть, фактически, мы можем записать нашу строку так:
`(std::cout << "I came, I saw, I conquered!") << std::endl;`

Задача `<<` в выходной поток отправить текст или модификатор. Сначала без проблем выполнится выражение в скобках. Теперь его возвращаемое значение (то есть `std::cout`) станет операндом, поэтому вторая операция `<<` теперь имеет в качестве левого операнда: `std::cout`, а в качестве правого: `std::endl`.

### Итог
Нашу программу мы могли бы записать и так:
```c++ 
// Маленькая программка на С++
#include <iostream>
int main()
{
    std::cout << "I came, I saw, I conquered!";
    std::cout << std::endl;
}
```

Но это дольше, поэтому разработчики сделали так, что операция `<<` возвращает свой левый операнд. Это дало нам возмодность писать так:
```c++ std::cout << "some text " << "some more text " << "even more text " << std::endl; ```

### Check yourself
Прежде чем идти дальше, убедитесь, что вы понимаете:
6. Какая разница между этими строками:
```c++
    std::cout << "first" << "second";
```
и

```c++
    std::cout << "first";
    std::cout << "second";
```
7. Какие из следующих выражений допустимы (если такие есть)?
   1. std::cout << "/*";
   2. std::cout << "*/";
   3. std::cout << /* "*/" */;
   4. std::cout << /* "*/" /* "/*" */;
8. Эта программа допустима, почему?
```c++
#include <iostream>
int main() std::cout << "Hi!";
```
9.  А эта?
```c++
#include <iostream>
int main()

    {{{{{{{{std::cout << "Hi!";}}}}}}}}
```
10. А как на счет этой?
```
#include <iostream>
/*Этот комментарий может занимать несколько строк, так как
в качестве начального и конечного ограничителя он использует
символы /* и */ */
int main() 
{
    std::cout << "Hi!";
}
```
11. И наконец, этой?
```
#include <iostream>
// /*Этот комментарий может занимать несколько строк, так как
// в качестве начального и конечного ограничителя он использует
// символы /* и */*/
int main() 
{
    std::cout << "Hi!";
}
```
